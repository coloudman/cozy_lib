import Controller from "../Element/Controller";
import CodeLoader from "../Loader/CodeLoader";
import Code from "../Element/Code";

import LinkingPoint from "../structClass/LinkingPoint";

import MixData from "../struct/MixData";
import LinkedControllers from "@src/structClass/LinkedControllers";
import ControllerLoaders from "@src/structClass/ControllerLoaders";
import LinkingPoints from "@src/structClass/LinkingPoints";

type Controllers = {
    [name : string]: Controller
}

export default class Mix {
    /*
    Code와 그에 연결된 Controller들,
    하위에 연결되어 있는 Mix들을 관리합니다.

    하위에 연결되어 있는 Mix들과 자신은 모두 같은 Controller들을 사용합니다.
    */

    controllerLoaders: ControllerLoaders;
    codeLoader: CodeLoader;

    code: Code;

    linkingPoints: {
        [linkingPointName: string] : LinkingPoint
    }

    controllers: Controllers

    //특정 타입 컨트롤러가 접근할 수 있는 링킹포인트에 있는 같은 타입의 컨트롤러들을 저장합니다. linkControllerses[컨트롤러 타입][링킹포인트 이름]
    linkedControllerses: {
        [controllerName: string] : LinkedControllers
    }

    constructor(codeLoader : CodeLoader, controllerLoaders : ControllerLoaders) {

        this.codeLoader = codeLoader;
        this.controllerLoaders = controllerLoaders;
        //this.mixData = mixData;

        this.linkedControllerses = {};
        this.controllers = {};
    }

    init(code : Code, linkingPoints : LinkingPoints) {
        this.code = code;
        this.linkingPoints = linkingPoints;
    }

    // 연결점 관련

    addDefaultLinkingPoints(names : string[]) {
        names.forEach(name => {
            if(!this.linkingPoints[name]) {
                this.addLinkingPoint(name);
            }
        });
    }
    addLinkingPoint(name : string) {
        this.linkingPoints[name] = new LinkingPoint();
    }
    removeLinkingPoint(name : string) {
        delete this.linkingPoints[name];
    }
    link(name : string, mix : Mix) {
        this.linkingPoints[name].link(mix);

        //기존에 있던 컨트롤러-링킹포인트 접근 오브젝트들에 이 링킹포인트 추가
        Object.entries(this.linkedControllerses).forEach(([controllerType, controllers]) => {
            controllers[name] = this.linkingPoints[name].linkedMix.addController(controllerType);
        });
    }
    unlink(name : string) {
        delete this.linkingPoints[name];
    }

    //유틸, 모든 연결된 연결점에서 실행
    runOnExistLinkingPoints(f : (linkingPointName : string, linkedMix : Mix) => any) {
        Object.entries(this.linkingPoints).forEach(([linkingPointName, linkingPoint]) => {
            if(linkingPoint.linked) {
                f(linkingPointName, linkingPoint.linked);
            }
        });
    }

    // 컨트롤러 연결
    addController(name : string): Controller {
        const linkedControllers = {} as LinkedControllers;
        this.runOnExistLinkingPoints((linkingPointName, linkedMix) => {
            linkedControllers[linkingPointName] = linkedMix.addController(name);
        });
        this.linkedControllerses[name] = linkedControllers;

        const controller = this.controllerLoaders[name].load(this.code, this.mixData.codeData, linkedControllers);

        this.controllers[name] = controller;
        return controller;
    }
    removeController(name : string) {
        this.runOnExistLinkingPoints((linkingPointName, linkedMix) => {
            linkedMix.removeController(name);
        });
        delete this.linkedControllerses[name];
        delete this.controllers[name];
    }
}